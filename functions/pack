# pack CLI helpers — sourced by pack() on first CLI invocation.
# Do NOT define function pack here — it lives in pack.ksh.

# Run build command (if any) in a subshell rooted at the package directory.
function _pack_run_build {
	typeset name="$1" dir="$2"
	typeset build_cmd
	build_cmd="${PACK_REGISTRY[$name].build}"
	[[ -z "$build_cmd" ]] && return 0
	# SECURITY: build commands execute in a subshell. Only source packages you trust.
	( cd "$dir" && eval "$build_cmd" ) || { print -u2 "pack: build failed for $name"; return 1; }
}

# Record commit + epoch timestamp in PACK_STATE.
function _pack_stamp {
	typeset dir="$1" name="$2"
	_pack_git_head "$dir"
	PACK_STATE[$name]=(commit="$REPLY" timestamp="$(printf '%(%s)T' now)")
}

# ── Worker Pool ──────────────────────────────────────────────────────────────
# Dispatch worker_func across up to PACK_JOBS parallel subshells via FIFO.
# Usage: _pack_pool <rc_assoc_array_name> <dir_var_name> <worker_func> name...
# Caller declares the associative array and dir variable; pool writes via nameref.
# Caller is responsible for removing the tmpdir.
#
# Stays outside func.ksh's abstraction: subshells break Result_t's nameref model.
function _pack_pool {
	typeset -n pool_rc="$1" pool_dir="$2"
	typeset worker="$3"; shift 3
	typeset -a queue=("$@")
	typeset -i total=${#queue[@]} active=0 next=0

	pool_dir=$(mktemp -d "${TMPDIR:-/tmp}/pack-pool.XXXXXX")
	typeset fifo="$pool_dir/.fifo"
	mkfifo "$fifo"
	typeset -i pool_fd
	exec {pool_fd}<>"$fifo"

	# Track worker PIDs manually for interrupt cleanup.
	# Workers spawn in pipe subshells (to stay out of the job table),
	# so jobs -p can't find them.
	typeset -a _pool_pids=()
	trap 'kill "${_pool_pids[@]}" 2>/dev/null; exec {pool_fd}<&-' INT TERM

	typeset name="" line="" _pool_last_pid=""

	while (( next < total )); do
		name="${queue[next]}"
		(( next++ ))
		# Pipe subshell: the pipe forces a real fork, so & inside
		# never enters the parent's job table. Worker PID piped back.
		_pool_last_pid=''
		{
			{ "$worker" "$name" > "$pool_dir/$name.log" 2>&1; print -r -- "$name"$'\t'"$?" >&${pool_fd}; } &
			print -r -- $!
		} | IFS= read -r _pool_last_pid
		(( ${_pool_last_pid:-0} > 0 )) && _pool_pids+=($_pool_last_pid)
		(( active++ ))
		(( _pack_progress.total > 0 )) && _pack_progress.pool_start "$name"
		if (( active >= PACK_JOBS )); then
			line=""
			if ! read -t 300 -r line <&${pool_fd}; then
				print -u2 "pack: worker pool: timed out waiting for worker"
				(( active-- ))
				(( _pack_progress.total > 0 )) && _pack_progress.pool_finish
				continue
			fi
			[[ -z "$line" ]] && { (( active-- )); (( _pack_progress.total > 0 )) && _pack_progress.pool_finish; continue; }
			pool_rc[${line%%$'\t'*}]="${line#*$'\t'}"
			(( active-- ))
			(( _pack_progress.total > 0 )) && _pack_progress.pool_finish
		fi
	done

	while (( active > 0 )); do
		line=""
		if ! read -t 300 -r line <&${pool_fd}; then
			print -u2 "pack: worker pool: timed out waiting for worker"
			(( active-- ))
			(( _pack_progress.total > 0 )) && _pack_progress.pool_finish
			continue
		fi
		[[ -z "$line" ]] && { (( active-- )); (( _pack_progress.total > 0 )) && _pack_progress.pool_finish; continue; }
		pool_rc[${line%%$'\t'*}]="${line#*$'\t'}"
		(( active-- ))
		(( _pack_progress.total > 0 )) && _pack_progress.pool_finish
	done

	trap - INT TERM
	exec {pool_fd}<&-
}

# ── Install Worker ───────────────────────────────────────────────────────────
# Runs in subshell — stdout/stderr redirected to log by _pack_pool.
# Creates a local Result_t; the pool captures exit code + log output.
function _pack_install_worker {
	typeset name="$1"
	typeset src dir br tag commit
	src="${PACK_REGISTRY[$name].source}"
	dir="${PACK_REGISTRY[$name].path}"
	br="${PACK_REGISTRY[$name].branch}"
	tag="${PACK_REGISTRY[$name].tag}"
	commit="${PACK_REGISTRY[$name].commit}"
	Result_t _piw_r
	_pack_git_clone _piw_r "$src" "$dir" "$br" "$tag" "$commit"
	if _piw_r.is_err; then
		print -u2 "${_piw_r.error}"
		return 1
	fi
}

# ── Update Worker ────────────────────────────────────────────────────────────
# Runs in subshell — stdout/stderr redirected to log by _pack_pool.
function _pack_update_worker {
	typeset name="$1"
	typeset dir br
	dir="${PACK_REGISTRY[$name].path}"
	br="${PACK_REGISTRY[$name].branch}"
	Result_t _puw_r
	_pack_git_update _puw_r "$dir" "$br"
	if _puw_r.is_err; then
		print -u2 "${_puw_r.error}"
		return 1
	fi
}

# ── install ──────────────────────────────────────────────────────────────────
function _pack_cmd_install {
	typeset -a names=("${@:-${!PACK_REGISTRY[@]}}")
	typeset -a queue
	typeset name
	Result_t _pci_acc

	# No packages declared (only self-registered 'pack')
	if (( $# == 0 && ${#names[@]} <= 1 )); then
		print "pack: no packages declared. Add packages to ${PACK_CONFIG} and try again."
		return 0
	fi

	# ── Collect — filter into queue, skip messages before progress starts ──
	for name in "${names[@]}"; do
		[[ -z "${PACK_REGISTRY[$name]+set}" ]] && { print -u2 "pack: unknown package: $name"; continue; }
		[[ "${PACK_REGISTRY[$name].disabled}" == true ]] && { print "pack: $name is disabled, skipping"; continue; }
		[[ "${PACK_REGISTRY[$name].local}" == true ]] && { print "pack: $name is local, skipping"; continue; }
		typeset _ipath
		_ipath="${PACK_REGISTRY[$name].path}"
		[[ -d "$_ipath" ]] && { print "pack: $name already installed"; continue; }
		queue+=("$name")
	done

	(( ${#queue[@]} == 0 )) && return 0

	# ── Dispatch ──
	_pack_progress.begin ${#queue[@]} "installed" "cloning"

	typeset -A _pack_rc
	typeset _pack_tmpdir=""
	if (( ${#queue[@]} == 1 )); then
		name="${queue[0]}"
		_pack_progress.item "$name"
		_pack_install_worker "$name"
		_pack_rc[$name]=$?
	else
		_pack_pool _pack_rc _pack_tmpdir _pack_install_worker "${queue[@]}"
	fi

	# Protect tmpdir from signal-induced leak
	[[ -n "$_pack_tmpdir" ]] && trap 'rm -rf "$_pack_tmpdir" 2>/dev/null' INT TERM

	# ── Finish — gather per-item results into accumulator ──
	typeset -i rc
	for name in "${queue[@]}"; do
		rc=${_pack_rc[$name]:-1}
		typeset dir
		dir="${PACK_REGISTRY[$name].path}"
		if (( rc != 0 )); then
			typeset _pci_msg="install failed"
			if [[ -n "$_pack_tmpdir" && -f "$_pack_tmpdir/$name.log" ]]; then
				_pci_msg="$(< "$_pack_tmpdir/$name.log")"
			fi
			_pack_progress.err "$name" "$_pci_msg"
			_pack_accum_err _pci_acc "${name}: ${_pci_msg}"
			continue
		fi
		_pack_run_build "$name" "$dir" || continue
		_pack_stamp "$dir" "$name"
		_pack_progress.ok "$name" "${PACK_STATE[$name].commit}"
	done

	_pack_progress.end

	# ── Cleanup ──
	if [[ -n "$_pack_tmpdir" ]]; then
		rm -rf "$_pack_tmpdir"
		trap - INT TERM
	fi

	_pack_report_errors _pci_acc
}

# ── update ───────────────────────────────────────────────────────────────────
function _pack_cmd_update {
	typeset -a names=("${@:-${!PACK_REGISTRY[@]}}")
	typeset -a queue
	typeset -A old_heads
	typeset name
	Result_t _pcu_acc

	# ── Collect — filter into queue, skip messages before progress starts ──
	for name in "${names[@]}"; do
		[[ -z "${PACK_REGISTRY[$name]+set}" ]] && { print -u2 "pack: unknown package: $name"; continue; }
		[[ "${PACK_REGISTRY[$name].disabled}" == true ]] && { print "pack: $name is disabled, skipping"; continue; }
		if [[ "${PACK_REGISTRY[$name].local}" == true ]]; then
			typeset _usrc
			_usrc="${PACK_REGISTRY[$name].source}"
			_pack_git_is_url "$_usrc" || { print "pack: $name is local (no remote), skipping"; continue; }
		fi
		typeset dir
		dir="${PACK_REGISTRY[$name].path}"
		[[ ! -d "$dir" ]] && { print -u2 "pack: $name not installed"; continue; }
		_pack_git_head "$dir"
		old_heads[$name]="$REPLY"
		queue+=("$name")
	done

	(( ${#queue[@]} == 0 )) && return 0

	# ── Dispatch ──
	_pack_progress.begin ${#queue[@]} "updated" "fetching"

	typeset -A _pack_rc
	typeset _pack_tmpdir=""
	if (( ${#queue[@]} == 1 )); then
		name="${queue[0]}"
		_pack_progress.item "$name"
		_pack_update_worker "$name"
		_pack_rc[$name]=$?
	else
		_pack_pool _pack_rc _pack_tmpdir _pack_update_worker "${queue[@]}"
	fi

	# Protect tmpdir from signal-induced leak
	[[ -n "$_pack_tmpdir" ]] && trap 'rm -rf "$_pack_tmpdir" 2>/dev/null' INT TERM

	# ── Finish ──
	typeset -i rc
	for name in "${queue[@]}"; do
		rc=${_pack_rc[$name]:-1}
		typeset dir
		dir="${PACK_REGISTRY[$name].path}"
		if (( rc != 0 )); then
			typeset _pcu_msg="update failed"
			if [[ -n "$_pack_tmpdir" && -f "$_pack_tmpdir/$name.log" ]]; then
				_pcu_msg="$(< "$_pack_tmpdir/$name.log")"
			fi
			_pack_progress.err "$name" "$_pcu_msg"
			_pack_accum_err _pcu_acc "${name}: ${_pcu_msg}"
			continue
		fi
		_pack_git_head "$dir"
		if [[ "$REPLY" != "${old_heads[$name]}" ]]; then
			_pack_run_build "$name" "$dir" || {
				_pack_accum_err _pcu_acc "${name}: build failed"
				continue
			}
			_pack_stamp "$dir" "$name"
			_pack_progress.ok "$name" "${old_heads[$name]} → $REPLY"
		else
			_pack_progress.ok "$name" "up to date"
		fi
	done

	_pack_progress.end

	# ── Cleanup ──
	if [[ -n "$_pack_tmpdir" ]]; then
		rm -rf "$_pack_tmpdir"
		trap - INT TERM
	fi

	_pack_report_errors _pcu_acc
}

# ── remove ───────────────────────────────────────────────────────────────────
function _pack_cmd_remove {
	(( $# < 1 )) && { print -u2 "pack: remove requires a package name"; return 2; }
	typeset name
	for name in "$@"; do
		[[ -z "${PACK_REGISTRY[$name]+set}" ]] && { print -u2 "pack: unknown package: $name"; continue; }
		# Warn if other packages depend on this one
		typeset _dep_pkg _dep_dep
		typeset -i _dep_i _dep_n
		for _dep_pkg in "${!PACK_CONFIGS[@]}"; do
			[[ "$_dep_pkg" == "$name" ]] && continue
			_dep_n=${#PACK_CONFIGS[$_dep_pkg].depends[@]}
			for (( _dep_i = 0; _dep_i < _dep_n; _dep_i++ )); do
				_dep_dep="${PACK_CONFIGS[$_dep_pkg].depends[_dep_i]}"
				_dep_dep="${_dep_dep%%'@'*}"
				[[ "$_dep_dep" == "$name" ]] && print -u2 "pack: warning: ${_dep_pkg} depends on ${name}"
			done
		done
		typeset loc dir
		loc="${PACK_REGISTRY[$name].local}"
		dir="${PACK_REGISTRY[$name].path}"
		# Only rm remote packages; local packages are just unregistered
		typeset _was_local=false
		[[ "$loc" == true ]] && _was_local=true
		if [[ "$loc" != true && -d "$dir" ]]; then
			if [[ -n "$dir" && "$dir" == "${PACK_PACKAGES}/"* ]]; then
				command rm -rf "$dir"
			else
				print -u2 "pack: $name: refusing to remove $dir (not under $PACK_PACKAGES)"
			fi
		fi
		[[ -d "$PACK_CACHE/$name" ]] && command rm -rf "$PACK_CACHE/$name"
		unset "PACK_REGISTRY[$name]" "PACK_CONFIGS[$name]" "PACK_STATE[$name]" "PACK_LOADED[$name]"
		# Remove from PACK_ORDER too
		typeset -a _new_order=()
		typeset _n
		for _n in "${PACK_ORDER[@]}"; do
			[[ "$_n" != "$name" ]] && _new_order+=("$_n")
		done
		PACK_ORDER=("${_new_order[@]}")
		if [[ "$_was_local" == true ]]; then
			print "pack: unregistered $name (local files unchanged)"
		else
			print "pack: removed $name"
		fi
	done
}

# ── list ─────────────────────────────────────────────────────────────────────
# POSIX-style function: shares caller's scope via _pack_each.
_pack_list_entry() {
	typeset name="$1"
	typeset dis loc dir ld status
	dis="${PACK_REGISTRY[$name].disabled:-}"
	loc="${PACK_REGISTRY[$name].local:-}"
	dir="${PACK_REGISTRY[$name].path:-}"
	ld="${PACK_REGISTRY[$name].load:-}"
	if [[ "$dis" == true ]]; then status="disabled"
	elif [[ "$loc" == true ]]; then
		if [[ -n "$dir" && -d "$dir" ]]; then status="local"
		else status="local/missing"; fi
	elif [[ -d "$dir" ]]; then status="installed"
	else status="missing"; fi
	# Dirty working tree indicator
	if [[ -d "${dir:-}/.git" ]]; then
		typeset _ple_p
		_ple_p=$(command git -C "$dir" status --porcelain 2>/dev/null)
		[[ -n "$_ple_p" ]] && status+='*'
	fi
	printf '%-20s %-12s %-8s %s\n' "$name" "$status" "$ld" "${PACK_LOADED[$name]:+yes}"
}

function _pack_cmd_list {
	(( ${#PACK_REGISTRY[@]} == 0 )) && { print "No packages declared."; return 0; }
	typeset status
	printf '%-20s %-12s %-8s %s\n' NAME STATUS LOAD LOADED
	printf '%-20s %-12s %-8s %s\n' ---- ------ ---- ------
	_pack_each _pack_list_entry
}

# ── info ─────────────────────────────────────────────────────────────────────
function _pack_cmd_info {
	(( $# < 1 )) && { print -u2 "pack: info requires a package name"; return 2; }
	typeset name="$1"
	[[ -z "${PACK_REGISTRY[$name]+set}" ]] && { print -u2 "pack: unknown package: $name"; return 1; }

	# Always shown
	print "Package:  $name"
	print "Source:   ${PACK_REGISTRY[$name].source}"
	print "Path:     ${PACK_REGISTRY[$name].path}"

	# Conditional scalar fields — only show when meaningful
	typeset _val
	_val="${PACK_REGISTRY[$name].branch}"
	[[ -n "$_val" ]] && print "Branch:   $_val"
	_val="${PACK_REGISTRY[$name].tag}"
	[[ -n "$_val" ]] && print "Tag:      $_val"
	_val="${PACK_REGISTRY[$name].build}"
	[[ -n "$_val" ]] && print "Build:    $_val"
	_val="${PACK_REGISTRY[$name].local}"
	[[ "$_val" == true ]] && print "Local:    true"
	_val="${PACK_REGISTRY[$name].disabled}"
	[[ "$_val" == true ]] && print "Disabled: true"

	# Always shown
	print "Load:     ${PACK_REGISTRY[$name].load}"
	print "Loaded:   ${PACK_LOADED[$name]:+yes}"

	# Config fields — print each populated field individually
	if [[ -n "${PACK_CONFIGS[$name]+set}" ]]; then
		typeset -i _i _n
		_n=${#PACK_CONFIGS[$name].fpath[@]}
		(( _n > 0 )) && print "Fpath:    ${PACK_CONFIGS[$name].fpath[*]}"
		_n=${#PACK_CONFIGS[$name].path[@]}
		(( _n > 0 )) && print "Path:     ${PACK_CONFIGS[$name].path[*]}"
		_n=${#PACK_CONFIGS[$name].depends[@]}
		(( _n > 0 )) && print "Depends:  ${PACK_CONFIGS[$name].depends[*]}"
		_n=${#PACK_CONFIGS[$name].alias[@]}
		(( _n > 0 )) && print "Alias:    ${PACK_CONFIGS[$name].alias[*]}"
		_n=${#PACK_CONFIGS[$name].env[@]}
		(( _n > 0 )) && print "Env:      ${PACK_CONFIGS[$name].env[*]}"
		_val="${PACK_CONFIGS[$name].rc}"
		if [[ -n "$_val" ]]; then
			# Truncate long rc snippets
			(( ${#_val} > 60 )) && _val="${_val:0:60}..."
			print "RC:       $_val"
		fi
	fi

	# State — formatted timestamp
	if [[ -n "${PACK_STATE[$name]+set}" ]]; then
		print "Commit:   ${PACK_STATE[$name].commit}"
		typeset _ts
		_ts="${PACK_STATE[$name].timestamp}"
		if [[ -n "$_ts" ]]; then
			printf 'Updated:  %(%Y-%m-%d %H:%M:%S)T\n' "#$_ts"
		fi
	fi

	typeset _info_path
	_info_path="${PACK_REGISTRY[$name].path}"
	if [[ -d "$_info_path/.git" ]]; then
		typeset br
		br=$(command git -C "$_info_path" branch --show-current 2>/dev/null)
		[[ -n "$br" ]] && print "Git HEAD: $br"
	fi
}

# ── self-update ──────────────────────────────────────────────────────────────
function _pack_cmd_self_update {
	if [[ -z "${PACK_REGISTRY[pack]+set}" ]]; then
		print -u2 "pack: self-update requires pack to be self-registered"
		return 1
	fi
	_pack_cmd_update pack
}

# ── help ─────────────────────────────────────────────────────────────────────
function _pack_cmd_help {
	print 'Usage: pack <command> [args]
       pack "<source>" [field=value ...]

Commands:
  install [name...]       Install packages (all declared if no name given)
  update  [name...]       Update packages from git
  remove  <name...>       Remove package(s)
  list                    Show all declared packages and status
  freeze                  Generate lockfile (pin versions)
  restore                 Install from lockfile
  info    <name>          Show detailed package info
  path    <name>          Print package root directory
  run     [--pkg] <name> <cmd>  Run command with package'\''s PATH
  diff                    Show changes since last freeze
  doctor  [--fix]         Diagnose and repair broken installations
  self-update             Update pack.ksh itself
  version                 Show pack.ksh version info
  help                    Show this message

Declaration:
  pack "user/repo" fpath=functions
  pack "gl:user/repo" branch=dev tag=v1.0 build="make"
  pack "$HOME/dev/plugin" fpath=functions
  pack "my-tool" depends=(dep1 dep2) load=now

Sources:
  user/repo          GitHub (default)
  gl:user/repo       GitLab
  bb:user/repo       Bitbucket
  /path, ~/path      Local filesystem
  https://...        Full URL

Fields:
  as, branch, tag, commit, url, local, load, build, disabled, entry, rc
  load: now (source entry point), autoload (default), manual
  Arrays: fpath, path, alias, env, depends  (use key=(val1 val2) syntax)'
}

# ── version ──────────────────────────────────────────────────────────────────
function _pack_cmd_version {
	print "pack.ksh"
	typeset _vpath
	_vpath="${PACK_REGISTRY[pack].path}"
	if [[ -d "$_vpath/.git" ]]; then
		_pack_git_head "$_vpath"
		print "  commit: $REPLY"
		typeset _vbr
		_vbr=$(command git -C "$_vpath" branch --show-current 2>/dev/null)
		[[ -n "$_vbr" ]] && print "  branch: $_vbr"
	fi
	print "  root:   $PACK_ROOT"
	print "  config: $PACK_CONFIG"
}

# ── path ─────────────────────────────────────────────────────────────
# Print a package's root directory. Intended for command substitution:
#   . "$(pack path my-plugin)/init.ksh"
function _pack_cmd_path {
	(( $# < 1 )) && { print -u2 "pack: path requires a package name"; return 2; }
	[[ -z "${PACK_REGISTRY[$1]+set}" ]] && { print -u2 "pack: unknown package: $1"; return 1; }
	print -r -- "${PACK_REGISTRY[$1].path}"
}

# ── run ──────────────────────────────────────────────────────────────────
# Run a command with a package's PATH dirs prepended (in a subshell).
function _pack_cmd_run {
	typeset name
	if [[ "${1:-}" == --pkg ]]; then
		shift; name="${1:-}"; shift
	else
		name="${1:-}"; shift
	fi
	[[ -z "$name" ]] && { print -u2 "pack: run: usage: pack run [--pkg name] <cmd> [args]"; return 2; }
	[[ -z "${PACK_REGISTRY[$name]+set}" ]] && { print -u2 "pack: run: unknown package: $name (use --pkg <name> <cmd> to disambiguate)"; return 1; }
	(( $# > 0 )) || { print -u2 "pack: run: no command specified"; return 2; }
	typeset pkg_path
	pkg_path="${PACK_REGISTRY[$name].path}"
	typeset new_path="$PATH"
	if [[ -n "${PACK_CONFIGS[$name]+set}" ]]; then
		typeset -i _ri _rn
		_rn=${#PACK_CONFIGS[$name].path[@]}
		typeset dir
		for (( _ri = 0; _ri < _rn; _ri++ )); do
			dir="${PACK_CONFIGS[$name].path[_ri]}"
			if [[ "$dir" == /* ]]; then new_path="$dir:$new_path"
			else new_path="$pkg_path/$dir:$new_path"; fi
		done
	fi
	( PATH="$new_path" "$@" )
}

# ── diff ─────────────────────────────────────────────────────────────────
# Show what changed since last pack freeze.
# POSIX-style function: shares caller's scope via _pack_each.
# Expects from _pack_cmd_diff: locked, diff_changed, diff_clean
_pack_diff_entry() {
	typeset name="$1"
	typeset pkg_path
	pkg_path="${PACK_REGISTRY[$name].path}"
	[[ -d "$pkg_path/.git" ]] || return 0
	if [[ -z "${locked[$name]:-}" ]]; then
		print "  + $name (new, not in lockfile)"
		(( diff_changed++ ))
	else
		_pack_git_head "$pkg_path"
		typeset head="$REPLY"
		typeset lck="${locked[$name]}"
		typeset lck_short="${lck:0:${#head}}"
		if [[ "$head" != "$lck_short" ]]; then
			print "  ~ $name (${lck_short} -> ${head})"
			(( diff_changed++ ))
		else
			(( diff_clean++ ))
		fi
		unset "locked[$name]"
	fi
}

function _pack_cmd_diff {
	_pack_lock_path; typeset lockfile="$REPLY"
	[[ -f "$lockfile" ]] || { print -u2 "pack: diff: no lockfile found (run 'pack freeze' first)"; return 1; }
	typeset -A locked
	typeset line lname lsource lcommit lts
	while IFS='|' read -r lname lsource lcommit lts; do
		[[ "$lname" == '#'* || -z "$lname" ]] && continue
		locked[$lname]="$lcommit"
	done < "$lockfile"
	typeset name
	typeset -i diff_changed=0 diff_clean=0
	_pack_each _pack_diff_entry _pack_filter_remote
	for name in "${!locked[@]}"; do
		print "  - $name (in lockfile but not declared)"
		(( diff_changed++ ))
	done
	if (( diff_changed == 0 )); then
		print "All ${diff_clean} package(s) match lockfile."
	else
		print "${diff_changed} changed, ${diff_clean} unchanged."
	fi
}

# ── doctor ───────────────────────────────────────────────────────────────────
# Diagnose and repair broken installations.
#
# All check helpers are POSIX-style so they share _pack_cmd_doctor's scope
# (counters _doc_ok/_doc_warn/_doc_fail/_doc_repaired, flag _doc_fix).
# Only _pack_doctor_repair_clone uses function-keyword (needs local Result_t).

# Clone helper for repair operations — function-keyword keeps Result_t local.
function _pack_doctor_repair_clone {
	typeset _pdrc_name="$1" _pdrc_src="$2" _pdrc_dest="$3"
	Result_t _pdrc_r
	_pack_git_clone _pdrc_r "$_pdrc_src" "$_pdrc_dest" \
		"${PACK_REGISTRY[$_pdrc_name].branch}" \
		"${PACK_REGISTRY[$_pdrc_name].tag}" \
		"${PACK_REGISTRY[$_pdrc_name].commit}"
	if _pdrc_r.is_ok; then
		print "    ✓ recloned"
		return 0
	else
		print -u2 "    ✗ reclone failed: ${_pdrc_r.error}"
		return 1
	fi
}

# Check 1: ksh version
_pack_doctor_ksh() {
	if [[ "${.sh.version}" == *93u+m* || "${.sh.version}" == *ksh26* ]]; then
		typeset -a _pdk_words=( ${.sh.version} )
		typeset _pdk_ver="${_pdk_words[2]}"
		print "  ✓ ksh $_pdk_ver"
		(( _doc_ok++ ))
	else
		print "  ✗ ksh — found ${.sh.version}, need 93u+m or ksh26"
		typeset _pdk_path
		_pdk_path=$(command -v ksh 2>/dev/null)
		[[ -n "$_pdk_path" ]] && print "    binary: $_pdk_path"
		(( _doc_fail++ ))
	fi
}

# Check 2: func.ksh dependency
_pack_doctor_func() {
	typeset -i _pdf_checks=0 _pdf_passed=0

	(( _pdf_checks++ ))
	[[ -n "${_FUNC_KSH_INIT:-}" ]] && (( _pdf_passed++ ))

	(( _pdf_checks++ ))
	[[ -d "${_FUNC_KSH_ASYNC_DIR:-/nonexistent}" ]] && (( _pdf_passed++ ))

	(( _pdf_checks++ ))
	if Future_t _pdf_test 2>/dev/null; then
		unset _pdf_test
		(( _pdf_passed++ ))
	fi

	if (( _pdf_passed == _pdf_checks )); then
		print "  ✓ func.ksh loaded (async: ok)"
		(( _doc_ok++ ))
		return
	fi

	print "  ✗ func.ksh — ${_pdf_passed}/${_pdf_checks} checks passed"
	typeset _pdf_dir="${PACK_SELF}/../func.ksh"

	if [[ ! -d "$_pdf_dir" ]] || [[ ! -d "$_pdf_dir/.git" ]]; then
		typeset _pdf_src=""
		[[ -n "${PACK_REGISTRY[func.ksh]+set}" ]] && _pdf_src="${PACK_REGISTRY[func.ksh].source}"
		if [[ -n "$_pdf_src" ]] && _pack_git_is_url "$_pdf_src"; then
			typeset _pdf_ans
			if [[ "$_doc_fix" == true ]]; then
				_pdf_ans=y
			else
				print -n "    → reclone func.ksh from ${_pdf_src}? [y/N] "
				read -r _pdf_ans
			fi
			if [[ "$_pdf_ans" == [yY] ]]; then
				[[ -n "$_pdf_dir" && -d "$_pdf_dir" ]] && command rm -rf "$_pdf_dir"
				if command git clone --depth 1 --single-branch -- "$_pdf_src" "$_pdf_dir" >/dev/null 2>&1; then
					print "    ✓ recloned (restart shell to load)"
					(( _doc_repaired++ ))
				else
					print -u2 "    ✗ reclone failed"
					(( _doc_fail++ ))
				fi
			else
				(( _doc_fail++ ))
			fi
		else
			print "    manual fix: clone func.ksh to ${_pdf_dir}"
			(( _doc_fail++ ))
		fi
	else
		(( _doc_fail++ ))
	fi
}

# Check 3: PACK_ROOT directory structure
_pack_doctor_dirs() {
	typeset -i _pdd_missing=0
	typeset _pdd_dir
	for _pdd_dir in "$PACK_PACKAGES" "$PACK_STATE_DIR" "$PACK_CACHE"; do
		[[ -d "$_pdd_dir" ]] || (( _pdd_missing++ ))
	done

	if (( _pdd_missing == 0 )); then
		print "  ✓ directory structure"
		(( _doc_ok++ ))
	else
		print "  ✗ directory structure — ${_pdd_missing} dir(s) missing"
		typeset _pdd_ans
		if [[ "$_doc_fix" == true ]]; then
			_pdd_ans=y
		else
			print -n "    → create missing directories? [y/N] "
			read -r _pdd_ans
		fi
		if [[ "$_pdd_ans" == [yY] ]]; then
			mkdir -p "$PACK_PACKAGES" "$PACK_STATE_DIR" "$PACK_CACHE"
			print "    ✓ created"
			(( _doc_repaired++ ))
		else
			(( _doc_fail++ ))
		fi
	fi
}

# Check 4 callback: per-package health check.
# POSIX-style: shares caller's scope (counters, _doc_fix flag).
# Same pattern as _pack_freeze_entry.
_pack_doctor_pkg_entry() {
	typeset name="$1"
	typeset _pdpe_path
	_pdpe_path="${PACK_REGISTRY[$name].path}"

	# Local packages: verify path exists
	if [[ "${PACK_REGISTRY[$name].local:-}" == true ]]; then
		if [[ -d "$_pdpe_path" ]]; then
			print "  ✓ $name (local)"
			(( _doc_ok++ ))
		else
			print "  ✗ $name — local path missing"
			(( _doc_fail++ ))
		fi
		return
	fi

	# Remote packages: full git health checks
	typeset _pdpe_status
	if [[ ! -d "$_pdpe_path" ]]; then
		_pdpe_status=missing
	elif [[ ! -d "$_pdpe_path/.git" ]]; then
		_pdpe_status=not-a-repo
	elif ! command git -C "$_pdpe_path" rev-parse HEAD >/dev/null 2>&1; then
		_pdpe_status=corrupt
	else
		_pdpe_status=ok
	fi

	case "$_pdpe_status" in
	ok)
		_pack_git_head "$_pdpe_path"
		print "  ✓ $name ($REPLY)"
		(( _doc_ok++ ))
		;;
	missing)
		print "  ✗ $name — missing"
		typeset _pdpe_src
		_pdpe_src="${PACK_REGISTRY[$name].source}"
		if _pack_git_is_url "$_pdpe_src"; then
			typeset _pdpe_ans
			if [[ "$_doc_fix" == true ]]; then
				_pdpe_ans=y
			else
				print -n "    → reclone from ${_pdpe_src}? [y/N] "
				read -r _pdpe_ans
			fi
			if [[ "$_pdpe_ans" == [yY] ]]; then
				if _pack_doctor_repair_clone "$name" "$_pdpe_src" "$_pdpe_path"; then
					(( _doc_repaired++ ))
				else
					(( _doc_fail++ ))
				fi
			else
				(( _doc_fail++ ))
			fi
		else
			print "    source is not a URL — cannot auto-repair"
			(( _doc_fail++ ))
		fi
		;;
	not-a-repo|corrupt)
		print "  ✗ $name — $_pdpe_status"
		typeset _pdpe_src
		_pdpe_src="${PACK_REGISTRY[$name].source}"
		if _pack_git_is_url "$_pdpe_src" && [[ -n "$_pdpe_path" && "$_pdpe_path" == "${PACK_PACKAGES}/"* ]]; then
			typeset _pdpe_ans
			if [[ "$_doc_fix" == true ]]; then
				_pdpe_ans=y
			else
				print -n "    → remove and reclone from ${_pdpe_src}? [y/N] "
				read -r _pdpe_ans
			fi
			if [[ "$_pdpe_ans" == [yY] ]]; then
				command rm -rf "$_pdpe_path"
				if _pack_doctor_repair_clone "$name" "$_pdpe_src" "$_pdpe_path"; then
					(( _doc_repaired++ ))
				else
					(( _doc_fail++ ))
				fi
			else
				(( _doc_fail++ ))
			fi
		else
			if ! _pack_git_is_url "$_pdpe_src"; then
				print "    source is not a URL — cannot auto-repair"
			else
				print "    path not under \$PACK_PACKAGES — refusing to remove"
			fi
			(( _doc_fail++ ))
		fi
		;;
	esac
}

# Check 4: registered packages
_pack_doctor_packages() {
	_pack_each _pack_doctor_pkg_entry _pack_filter_enabled
}

# Check 5: stale directories not in registry
_pack_doctor_orphans() {
	typeset _pdo_entry _pdo_name _pdo_dir
	for _pdo_entry in "$PACK_PACKAGES"/*/; do
		[[ -d "$_pdo_entry" ]] || continue
		_pdo_name="${_pdo_entry%/}"
		_pdo_name="${_pdo_name##*/}"
		[[ -n "${PACK_REGISTRY[$_pdo_name]+set}" ]] && continue
		print "  ! orphan: ${_pdo_name}/"
		(( _doc_warn++ ))
		_pdo_dir="${_pdo_entry%/}"
		if [[ -n "$_pdo_dir" && "$_pdo_dir" == "${PACK_PACKAGES}/"* ]]; then
			typeset _pdo_ans
			if [[ "$_doc_fix" == true ]]; then
				_pdo_ans=y
			else
				print -n "    → remove ${_pdo_dir}? [y/N] "
				read -r _pdo_ans
			fi
			if [[ "$_pdo_ans" == [yY] ]]; then
				command rm -rf "$_pdo_dir"
				print "    ✓ removed"
				(( _doc_repaired++ ))
			fi
		fi
	done
}

# Check 6 callback: dirty working tree detection.
_pack_doctor_dirty_entry() {
	typeset name="$1"
	typeset _pdde_path
	_pdde_path="${PACK_REGISTRY[$name].path:-}"
	[[ -d "$_pdde_path/.git" ]] || return 0

	typeset _pdde_p
	_pdde_p=$(command git -C "$_pdde_path" status --porcelain 2>/dev/null) || return 0
	[[ -z "$_pdde_p" ]] && return 0

	typeset -i _pdde_count=0
	while IFS= read -r _; do
		(( _pdde_count++ ))
	done <<< "$_pdde_p"

	print "  ! $name — dirty working tree (${_pdde_count} changed file(s))"
	(( _doc_warn++ ))
}

# Check 6: dirty working trees
_pack_doctor_dirty() {
	_pack_each _pack_doctor_dirty_entry _pack_filter_installed
}

# Check 7: dependency validation
_pack_doctor_deps() {
	typeset -i _pddp_ok=0 _pddp_fail=0
	typeset _pddp_name _pddp_dep _pddp_dep_name _pddp_dep_path _pddp_sf _pddp_entry

	for _pddp_name in "${!PACK_REGISTRY[@]}"; do
		[[ -z "${PACK_CONFIGS[$_pddp_name]+set}" ]] && continue
		typeset -i _pddp_n=0
		_pddp_n=${#PACK_CONFIGS[$_pddp_name].depends[@]}
		(( _pddp_n == 0 )) && continue

		typeset -i _pddp_i
		for (( _pddp_i = 0; _pddp_i < _pddp_n; _pddp_i++ )); do
			_pddp_dep="${PACK_CONFIGS[$_pddp_name].depends[_pddp_i]}"
			_pddp_dep_name="${_pddp_dep%%@*}"

			# Check registered
			if [[ -z "${PACK_REGISTRY[$_pddp_dep_name]+set}" ]]; then
				print "  ✗ $_pddp_name → $_pddp_dep_name (not registered)"
				(( _pddp_fail++ ))
				continue
			fi

			# Check directory exists
			_pddp_dep_path="${PACK_REGISTRY[$_pddp_dep_name].path:-}"
			if [[ ! -d "$_pddp_dep_path" ]]; then
				print "  ✗ $_pddp_name → $_pddp_dep_name (directory missing)"
				(( _pddp_fail++ ))

				# --fix: offer to install if remote
				if [[ "$_doc_fix" == true ]] && \
				   _pack_git_is_url "${PACK_REGISTRY[$_pddp_dep_name].source:-}"; then
					_pack_cmd_install "$_pddp_dep_name" && (( _doc_repaired++ ))
				fi
				continue
			fi

			# Check entry point exists
			_pddp_sf="${PACK_REGISTRY[$_pddp_dep_name].source_file:-}"
			_pddp_entry=""
			if [[ -n "$_pddp_sf" ]]; then
				if [[ "$_pddp_sf" == /* ]]; then
					_pddp_entry="$_pddp_sf"
				else
					_pddp_entry="$_pddp_dep_path/$_pddp_sf"
				fi
			elif [[ -f "$_pddp_dep_path/init.ksh" ]]; then
				_pddp_entry="$_pddp_dep_path/init.ksh"
			elif [[ -f "$_pddp_dep_path/plugin.ksh" ]]; then
				_pddp_entry="$_pddp_dep_path/plugin.ksh"
			elif [[ -f "$_pddp_dep_path/${_pddp_dep_name}.ksh" ]]; then
				_pddp_entry="$_pddp_dep_path/${_pddp_dep_name}.ksh"
			fi

			if [[ -n "$_pddp_entry" && -f "$_pddp_entry" ]]; then
				(( _pddp_ok++ ))
			elif [[ "${PACK_REGISTRY[$_pddp_dep_name].load:-}" == manual ]]; then
				# Manual-load packages may not need an entry point
				(( _pddp_ok++ ))
			else
				print "  ✗ $_pddp_name → $_pddp_dep_name (no entry point)"
				(( _pddp_fail++ ))
			fi
		done
	done

	if (( _pddp_ok + _pddp_fail == 0 )); then
		return 0  # no dependencies declared anywhere
	fi

	if (( _pddp_fail == 0 )); then
		print "  ✓ dependencies (${_pddp_ok} verified)"
		(( _doc_ok++ ))
	else
		(( _doc_fail += _pddp_fail ))
	fi
}

# Check 8 callback: behind remote detection.
_pack_doctor_behind_entry() {
	typeset name="$1"
	typeset _pdbe_path
	_pdbe_path="${PACK_REGISTRY[$name].path:-}"
	[[ -d "$_pdbe_path/.git" ]] || return 0

	# Skip if network already failed
	(( _doc_net_ok == 0 )) && return 0

	_pack_git_full_head "$_pdbe_path" || return 0
	typeset _pdbe_local
	_pdbe_local=$REPLY

	typeset _pdbe_src _pdbe_ref
	_pdbe_src="${PACK_REGISTRY[$name].source:-}"
	_pdbe_ref="${PACK_REGISTRY[$name].branch:-${PACK_REGISTRY[$name].tag:-}}"

	if ! _pack_git_remote_head "$_pdbe_src" "${_pdbe_ref:-HEAD}"; then
		if (( _doc_net_ok < 0 )); then
			# First network failure — warn and disable further checks
			print "  ! network unavailable — skipping remote checks"
			(( _doc_warn++ ))
			_doc_net_ok=0
		fi
		return 0
	fi
	_doc_net_ok=1

	if [[ "$_pdbe_local" == "$REPLY" ]]; then
		return 0
	fi

	print "  ! $name — behind remote (${_pdbe_local:0:7} → ${REPLY:0:7})"
	(( _doc_warn++ ))

	# --fix: offer to update
	if [[ "$_doc_fix" == true ]]; then
		_pack_cmd_update "$name" && (( _doc_repaired++ ))
	fi
}

# Check 8: behind remote
_pack_doctor_behind() {
	typeset -i _doc_net_ok=-1  # -1=untested, 0=failed, 1=ok
	_pack_each _pack_doctor_behind_entry _pack_filter_remote
}

function _pack_cmd_doctor {
	typeset _doc_fix=false
	typeset -i _doc_ok=0 _doc_warn=0 _doc_fail=0 _doc_repaired=0

	[[ "${1:-}" == --fix ]] && _doc_fix=true

	print "pack doctor"
	_pack_doctor_ksh
	_pack_doctor_func
	_pack_doctor_dirs
	_pack_doctor_packages
	_pack_doctor_orphans
	_pack_doctor_dirty
	_pack_doctor_deps
	_pack_doctor_behind

	# Summary
	typeset -i _doc_total=$(( _doc_ok + _doc_fail + _doc_warn + _doc_repaired ))
	typeset -a _parts=()
	(( _doc_ok > 0 )) && _parts+=("${_doc_ok} ok")
	(( _doc_repaired > 0 )) && _parts+=("${_doc_repaired} repaired")
	(( _doc_warn > 0 )) && _parts+=("${_doc_warn} warning")
	(( _doc_fail > 0 )) && _parts+=("${_doc_fail} failed")

	typeset _summary=""
	typeset -i _i
	for (( _i = 0; _i < ${#_parts[@]}; _i++ )); do
		(( _i > 0 )) && _summary+=", "
		_summary+="${_parts[_i]}"
	done

	print ""
	print "[${_doc_total} checked] $_summary"

	(( _doc_fail > 0 )) && return 1
	return 0
}
