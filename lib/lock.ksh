# pack.ksh — Lockfile support for reproducible installations
# Sourced by pack.ksh at startup; not intended for standalone execution.

# ── Lock Path ─────────────────────────────────────────────────────────
function _pack_lock_path {
    REPLY="$PACK_STATE_DIR/pack.lock"
}

# ── Freeze ────────────────────────────────────────────────────────────
# Snapshot current installed state to a lockfile. Each git-sourced package
# is recorded with its full commit hash so that pack_restore can recreate
# the exact environment later.
function pack_freeze {
    _pack_lock_path
    typeset lockfile="$REPLY"
    typeset -i count=0
    typeset ts name meta source pkg_path

    ts=$(date -u +%Y-%m-%dT%H:%M:%S) || {
        print -u2 "pack: could not determine timestamp"
        return 1
    }

    {
        print "# pack.lock — generated by pack_freeze"
        print "# Do not edit manually"

        for name in "${!PACK_REGISTRY[@]}"; do
            meta="${PACK_REGISTRY[$name]}"

            # Skip disabled packages
            [[ "$meta" == *"disabled=true"* ]] && continue

            # Skip local packages
            [[ "$meta" == *"local=true"* ]] && continue

            # Extract source URL
            source="${meta#*source=}"; source="${source%%;*}"
            [[ -z "$source" ]] && continue

            # Extract installed path
            pkg_path="${meta#*path=}"; pkg_path="${pkg_path%%;*}"

            # Only freeze packages that are actually cloned
            [[ -d "${pkg_path}/.git" ]] || continue

            _pack_git_full_head "$pkg_path"
            [[ -z "$REPLY" ]] && {
                print -u2 "pack: warning: could not read HEAD for ${name}"
                continue
            }

            print "${name}|${source}|${REPLY}|${ts}"
            (( count++ ))
        done
    } > "$lockfile"

    print "pack: frozen ${count} package(s) to ${lockfile}"
}

# ── Restore ───────────────────────────────────────────────────────────
# Install packages from the lockfile at their exact recorded commits,
# ignoring any branch/tag declarations in pack.ksh.
function pack_restore {
    _pack_lock_path
    typeset lockfile="$REPLY"

    [[ -f "$lockfile" ]] || {
        print -u2 "pack: no lockfile found at ${lockfile}"
        return 1
    }

    typeset -i count=0 errors=0
    typeset line name source commit ts

    while IFS='|' read -r name source commit ts; do
        # Skip comments and blank lines
        [[ "$name" == '#'* || -z "$name" ]] && continue

        typeset dest="$PACK_PACKAGES/$name"

        if [[ -d "$dest" ]]; then
            print "pack: ${name} already present, skipping"
        else
            _pack_git_clone "$source" "$dest" "" "" "$commit" || {
                print -u2 "pack: failed to restore ${name} at ${commit}"
                (( errors++ ))
                continue
            }
        fi

        PACK_STATE[$name]="${commit}:${ts}"
        (( count++ ))
    done < "$lockfile"

    if (( errors > 0 )); then
        print -u2 "pack: restored ${count} package(s) with ${errors} error(s)"
        return 1
    fi

    print "pack: restored ${count} package(s) from lockfile"
}
