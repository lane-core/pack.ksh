# pack.ksh — Lockfile support for reproducible installations
# Sourced by pack.ksh at startup; not intended for standalone execution.

# ── Lock Path ─────────────────────────────────────────────────────────
function _pack_lock_path {
    REPLY="$PACK_STATE_DIR/pack.lock"
}

# ── Freeze ────────────────────────────────────────────────────────────
# Snapshot current installed state to a lockfile. Each git-sourced package
# is recorded with its full commit hash so that pack_restore can recreate
# the exact environment later.

# POSIX-style counter: increments _pf_total for each freezable package.
_pack_freeze_count() {
    typeset _pfc_path
    _pfc_path="${PACK_REGISTRY[$1].path}"
    [[ -z "${PACK_REGISTRY[$1].source}" ]] && return 0
    [[ -d "${_pfc_path}/.git" ]] || return 0
    (( _pf_total++ ))
}

# POSIX-style function: shares caller's scope via _pack_each.
# Expects from pack_freeze: _pf_ts, _pf_count
_pack_freeze_entry() {
    typeset name="$1"
    typeset _pfe_source _pfe_path
    _pfe_source="${PACK_REGISTRY[$name].source}"
    [[ -z "$_pfe_source" ]] && return 0

    _pfe_path="${PACK_REGISTRY[$name].path}"

    # Only freeze packages that are actually cloned
    [[ -d "${_pfe_path}/.git" ]] || return 0

    _pack_git_full_head "$_pfe_path"
    [[ -z "$REPLY" ]] && {
        _pack_progress.err "$name" "could not read HEAD"
        return 0
    }

    _pack_progress.ok "$name" "${REPLY:0:7}"
    print "${name}|${_pfe_source}|${REPLY}|${_pf_ts}"
    (( _pf_count++ ))
}

function pack_freeze {
    _pack_lock_path
    typeset lockfile="$REPLY"
    typeset -i _pf_count=0 _pf_total=0
    typeset _pf_ts

    _pf_ts=$(date -u +%Y-%m-%dT%H:%M:%S) || {
        print -u2 "pack: could not determine timestamp"
        return 1
    }

    # Count freezable packages first for progress total
    _pack_each _pack_freeze_count _pack_filter_remote
    _pack_progress.begin $_pf_total "frozen"

    {
        print "# pack.lock — generated by pack_freeze"
        print "# Do not edit manually"

        _pack_each _pack_freeze_entry _pack_filter_remote
    } > "$lockfile"

    _pack_progress.end
    print "pack: frozen ${_pf_count} package(s) to ${lockfile}"
}

# ── Restore ───────────────────────────────────────────────────────────
# Install packages from the lockfile at their exact recorded commits,
# ignoring any branch/tag declarations in pack.ksh. Clones run
# concurrently via defer/await; results are collected sequentially.
function pack_restore {
    _pack_lock_path
    typeset lockfile="$REPLY"

    [[ -f "$lockfile" ]] || {
        print -u2 "pack: no lockfile found at ${lockfile}"
        return 1
    }

    typeset -i _prs_count=0
    typeset _prs_name _prs_source _prs_commit _prs_ts _prs_dest
    typeset -a _prs_d_names=() _prs_d_commits=() _prs_d_ts=()
    Result_t _prs_acc

    # Pass 1: Read lockfile, handle present packages, defer missing clones
    while IFS='|' read -r _prs_name _prs_source _prs_commit _prs_ts; do
        [[ "$_prs_name" == '#'* || -z "$_prs_name" ]] && continue

        _prs_dest="$PACK_PACKAGES/$_prs_name"

        if [[ -d "$_prs_dest" ]]; then
            print "pack: ${_prs_name} already present, skipping"
            PACK_STATE[$_prs_name]=(commit="$_prs_commit" timestamp="$_prs_ts")
            (( _prs_count++ ))
        else
            _prs_d_names+=("$_prs_name")
            _prs_d_commits+=("$_prs_commit")
            _prs_d_ts+=("$_prs_ts")
            _pack_defer_clone "$_prs_name" "$_prs_source" "$_prs_dest" "" "" "$_prs_commit"
        fi
    done < "$lockfile"

    # Pass 2: Await deferred clones and update state
    _pack_progress.begin ${#_prs_d_names[@]} "restored" "cloning"

    typeset -i _prs_i
    for (( _prs_i = 0; _prs_i < ${#_prs_d_names[@]}; _prs_i++ )); do
        _prs_name="${_prs_d_names[$_prs_i]}"
        _pack_progress.item "$_prs_name"

        Result_t _prs_cr
        _pack_await_clone _prs_cr "$_prs_name"
        if _prs_cr.is_err; then
            _pack_progress.err "$_prs_name" "clone failed"
            _pack_accum_err _prs_acc "${_prs_name}: ${_prs_cr.error}"
            continue
        fi

        PACK_STATE[$_prs_name]=(commit="${_prs_d_commits[$_prs_i]}" timestamp="${_prs_d_ts[$_prs_i]}")
        (( _prs_count++ ))
        _pack_progress.ok "$_prs_name" "${_prs_d_commits[$_prs_i]:0:7}"
    done

    _pack_progress.end
    print "pack: restored ${_prs_count} package(s) from lockfile"
    _pack_report_errors _prs_acc
    return $?
}
