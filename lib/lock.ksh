# pack.ksh — Lockfile support for reproducible installations
# Sourced by pack.ksh at startup; not intended for standalone execution.

# ── Lock Path ─────────────────────────────────────────────────────────
function _pack_lock_path {
    REPLY="$PACK_STATE_DIR/pack.lock"
}

# ── Freeze ────────────────────────────────────────────────────────────
# Snapshot current installed state to a lockfile. Each git-sourced package
# is recorded with its full commit hash so that pack_restore can recreate
# the exact environment later.
# POSIX-style function: shares caller's scope via _pack_each.
# Expects from pack_freeze: ts, count, source, pkg_path
_pack_freeze_entry() {
    typeset name="$1"
    source="${PACK_REGISTRY[$name].source}"
    [[ -z "$source" ]] && return 0

    pkg_path="${PACK_REGISTRY[$name].path}"

    # Only freeze packages that are actually cloned
    [[ -d "${pkg_path}/.git" ]] || return 0

    _pack_git_full_head "$pkg_path"
    [[ -z "$REPLY" ]] && {
        print -u2 "pack: warning: could not read HEAD for ${name}"
        return 0
    }

    print -u2 "pack: freeze: ${name} (${REPLY:0:7})"
    print "${name}|${source}|${REPLY}|${ts}"
    (( count++ ))
}

function pack_freeze {
    _pack_lock_path
    typeset lockfile="$REPLY"
    typeset -i count=0
    typeset ts source pkg_path

    ts=$(date -u +%Y-%m-%dT%H:%M:%S) || {
        print -u2 "pack: could not determine timestamp"
        return 1
    }

    {
        print "# pack.lock — generated by pack_freeze"
        print "# Do not edit manually"

        _pack_each _pack_freeze_entry _pack_filter_remote
    } > "$lockfile"

    print "pack: frozen ${count} package(s) to ${lockfile}"
}

# ── Restore ───────────────────────────────────────────────────────────
# Install packages from the lockfile at their exact recorded commits,
# ignoring any branch/tag declarations in pack.ksh.
function pack_restore {
    _pack_lock_path
    typeset lockfile="$REPLY"

    [[ -f "$lockfile" ]] || {
        print -u2 "pack: no lockfile found at ${lockfile}"
        return 1
    }

    typeset -i count=0
    typeset line name source commit ts
    _pack_errors_clear

    while IFS='|' read -r name source commit ts; do
        # Skip comments and blank lines
        [[ "$name" == '#'* || -z "$name" ]] && continue

        typeset dest="$PACK_PACKAGES/$name"

        if [[ -d "$dest" ]]; then
            print "pack: ${name} already present, skipping"
        else
            _pack_git_clone "$source" "$dest" "" "" "$commit" || {
                _pack_error "$name"
                continue
            }
        fi

        PACK_STATE[$name]=(commit="$commit" timestamp="$ts")
        (( count++ ))
    done < "$lockfile"

    print "pack: restored ${count} package(s) from lockfile"
    _pack_errors_report
    return $?
}
